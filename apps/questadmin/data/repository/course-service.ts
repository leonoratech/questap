/**
 * Server-side Course Repository
 * Handles all Firebase operations for courses on the server
 */

import { Course, CourseSearchFilters, CourseStats, CreateCourseRequest } from '@/data/models/course';
import { adminDb } from '@/data/repository/firebase-admin';
import { BaseRepository } from './base-service';

const COURSE_COLLECTION = 'courses';

export class CourseRepository extends BaseRepository<Course> {
    constructor() {
        super(COURSE_COLLECTION);
    }

    async createCourse(data: CreateCourseRequest): Promise<string> {
        // TODO: Fetch instructor name from user repository
        const instructor = 'Unknown Instructor' // Placeholder until we fetch from user service
        
        const courseData = {
            ...data,
            // Note: Do not include 'id' field as it will be auto-generated by Firebase
            instructor,
            isPublished: data.status === 'published' || false,
            featured: data.featured || false,
            status: data.status || 'draft',
            createdAt: new Date(),
            updatedAt: new Date(),
        }

        const docRef = await adminDb.collection(COURSE_COLLECTION).add(courseData)
        return docRef.id
    }

    async searchCourses(filters: CourseSearchFilters): Promise<Course[]> {
        try {
            let coursesQuery: FirebaseFirestore.Query = adminDb.collection(COURSE_COLLECTION);

            // Apply filters
            if (filters.instructorId) {
                coursesQuery = coursesQuery.where('instructorId', '==', filters.instructorId);
            }

            if (filters.categoryId) {
                coursesQuery = coursesQuery.where('categoryId', '==', filters.categoryId);
            }

            if (filters.difficultyId) {
                coursesQuery = coursesQuery.where('difficultyId', '==', filters.difficultyId);
            }

            if (filters.status) {
                coursesQuery = coursesQuery.where('status', '==', filters.status);
            }

            if (filters.featured !== undefined) {
                coursesQuery = coursesQuery.where('featured', '==', filters.featured);
            }

            // Apply ordering (default by creation date)
            coursesQuery = coursesQuery.orderBy('createdAt', 'desc');

            // Apply limit if specified
            if (filters.limit) {
                coursesQuery = coursesQuery.limit(filters.limit);
            }

            const querySnapshot = await coursesQuery.get();
            let courses = querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });

            // Apply text search filter in memory (to avoid composite index requirements)
            if (filters.search && filters.search.trim()) {
                const searchLower = filters.search.toLowerCase().trim();
                courses = courses.filter(course => {
                    const title = (course.title || '').toLowerCase();
                    const description = (course.description || '').toLowerCase();
                    const instructor = (course.instructor || '').toLowerCase();
                    // Note: categoryId is now an ID, search would need category name lookup
                    
                    return title.includes(searchLower) ||
                           description.includes(searchLower) ||
                           instructor.includes(searchLower);
                });
            }

            return courses;
        } catch (error) {
            console.error('Error searching courses:', error);
            throw new Error('Failed to search courses');
        }
    }

    async getCoursesByInstructor(instructorId: string, published?: boolean): Promise<Course[]> {
        try {
            let coursesQuery = adminDb.collection(COURSE_COLLECTION)
                .where('instructorId', '==', instructorId);

            if (published !== undefined) {
                coursesQuery = coursesQuery.where('isPublished', '==', published);
            }

            coursesQuery = coursesQuery.orderBy('createdAt', 'desc');

            const querySnapshot = await coursesQuery.get();
            return querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
        } catch (error) {
            console.error('Error fetching courses by instructor:', error);
            throw new Error('Failed to fetch courses by instructor');
        }
    }

    async getPublishedCourses(limit?: number): Promise<Course[]> {
        try {
            let coursesQuery = adminDb.collection(COURSE_COLLECTION)
                .where('status', '==', 'published')
                .where('isPublished', '==', true)
                .orderBy('createdAt', 'desc');

            if (limit) {
                coursesQuery = coursesQuery.limit(limit);
            }

            const querySnapshot = await coursesQuery.get();
            return querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
        } catch (error) {
            console.error('Error fetching published courses:', error);
            throw new Error('Failed to fetch published courses');
        }
    }

    async getFeaturedCourses(limit?: number): Promise<Course[]> {
        try {
            let coursesQuery = adminDb.collection(COURSE_COLLECTION)
                .where('featured', '==', true)
                .where('status', '==', 'published')
                .orderBy('createdAt', 'desc');

            if (limit) {
                coursesQuery = coursesQuery.limit(limit);
            }

            const querySnapshot = await coursesQuery.get();
            return querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
        } catch (error) {
            console.error('Error fetching featured courses:', error);
            throw new Error('Failed to fetch featured courses');
        }
    }

    async getCoursesByCategory(categoryId: string, limit?: number): Promise<Course[]> {
        try {
            let coursesQuery = adminDb.collection(COURSE_COLLECTION)
                .where('categoryId', '==', categoryId)
                .where('status', '==', 'published')
                .orderBy('createdAt', 'desc');

            if (limit) {
                coursesQuery = coursesQuery.limit(limit);
            }

            const querySnapshot = await coursesQuery.get();
            return querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
        } catch (error) {
            console.error('Error fetching courses by category:', error);
            throw new Error('Failed to fetch courses by category');
        }
    }

    async getCourseStats(): Promise<CourseStats> {
        try {
            const coursesSnapshot = await adminDb.collection(COURSE_COLLECTION).get();
            
            const stats: CourseStats = {
                totalCourses: 0,
                publishedCourses: 0,
                draftCourses: 0,
                archivedCourses: 0,
                averageRating: 0,
                coursesByCategory: {},
                coursesByDifficulty: {}
            };

            let totalRating = 0;
            let ratedCoursesCount = 0;

            coursesSnapshot.docs.forEach(doc => {
                const data = doc.data() as Course;
                stats.totalCourses++;

                // Count by status
                if (data.status === 'published') {
                    stats.publishedCourses++;
                } else if (data.status === 'draft') {
                    stats.draftCourses++;
                } else if (data.status === 'archived') {
                    stats.archivedCourses++;
                }
                
                // Calculate average rating
                if (data.rating && data.ratingCount && data.ratingCount > 0) {
                    totalRating += data.rating * data.ratingCount;
                    ratedCoursesCount += data.ratingCount;
                }

                // Count by category
                if (data.categoryId) {
                    stats.coursesByCategory[data.categoryId] = (stats.coursesByCategory[data.categoryId] || 0) + 1;
                }

                // Count by difficulty
                if (data.difficultyId) {
                    stats.coursesByDifficulty[data.difficultyId] = (stats.coursesByDifficulty[data.difficultyId] || 0) + 1;
                }
            });

            // Calculate average rating
            if (ratedCoursesCount > 0) {
                stats.averageRating = totalRating / ratedCoursesCount;
            }

            return stats;
        } catch (error) {
            console.error('Error calculating course stats:', error);
            throw new Error('Failed to calculate course stats');
        }
    }

    async getCategories(): Promise<string[]> {
        try {
            const coursesSnapshot = await adminDb.collection(COURSE_COLLECTION).get();
            const categories = new Set<string>();

            coursesSnapshot.docs.forEach(doc => {
                const data = doc.data() as Course;
                if (data.categoryId) {
                    categories.add(data.categoryId);
                }
            });

            return Array.from(categories).sort();
        } catch (error) {
            console.error('Error fetching course categories:', error);
            throw new Error('Failed to fetch course categories');
        }
    }

    async duplicateCourse(courseId: string, newTitle: string, instructorId: string): Promise<Course> {
        try {
            const originalCourse = await this.getById(courseId);
            
            const duplicatedCourse = {
                ...originalCourse,
                title: newTitle,
                instructorId: instructorId,
                status: 'draft' as const,
                isPublished: false,
                rating: 0,
                ratingCount: 0,
                featured: false
            };

            // Remove id and timestamps as they will be set by create method
            const { id, createdAt, updatedAt, ...courseData } = duplicatedCourse;

            return await this.create(courseData as Course);
        } catch (error) {
            console.error('Error duplicating course:', error);
            throw new Error('Failed to duplicate course');
        }
    }

    /**
     * Association-related methods
     */
    async getCoursesByProgram(programId: string): Promise<Course[]> {
        try {
            // Use array-contains for associations array
            const coursesQuery = adminDb.collection(COURSE_COLLECTION)
                .where('associations', 'array-contains', { programId });
            // Note: array-contains only matches full objects, so fallback to in-memory filter
            const querySnapshot = await coursesQuery.get();
            let courses = querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
            // Fallback: filter in-memory for any association with matching programId
            courses = courses.filter(course =>
                course.associations?.some(a => a.programId === programId)
            );
            return courses;
        } catch (error) {
            console.error('Error fetching courses by program:', error);
            throw new Error('Failed to fetch courses by program');
        }
    }

    async getCoursesBySubject(subjectId: string): Promise<Course[]> {
        try {
            const querySnapshot = await adminDb.collection(COURSE_COLLECTION).get();
            let courses = querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
            // Filter in-memory for any association with matching subjectId
            courses = courses.filter(course =>
                course.associations?.some(a => a.subjectId === subjectId)
            );
            return courses;
        } catch (error) {
            console.error('Error fetching courses by subject:', error);
            throw new Error('Failed to fetch courses by subject');
        }
    }

    async getCoursesByProgramAndYear(programId: string, yearOrSemester: number): Promise<Course[]> {
        try {
            const querySnapshot = await adminDb.collection(COURSE_COLLECTION).get();
            let courses = querySnapshot.docs.map(doc => {
                const data = doc.data();
                return {
                    id: doc.id,
                    ...data,
                    createdAt: data.createdAt?.toDate?.() || data.createdAt,
                    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,
                } as Course;
            });
            // Filter in-memory for any association with matching programId and yearOrSemester
            courses = courses.filter(course =>
                course.associations?.some(a => a.programId === programId && a.yearOrSemester === yearOrSemester)
            );
            return courses;
        } catch (error) {
            console.error('Error fetching courses by program and year:', error);
            throw new Error('Failed to fetch courses by program and year');
        }
    }

    /**
     * Update all associations for a course (replace the array)
     */
    async updateCourseAssociations(courseId: string, associations: any[]): Promise<void> {
        try {
            await this.update(courseId, {
                associations,
                updatedAt: new Date()
            });
        } catch (error) {
            console.error('Error updating course associations:', error);
            throw new Error('Failed to update course associations');
        }
    }

    /**
     * Remove all associations from a course
     */
    async removeAllCourseAssociations(courseId: string): Promise<void> {
        try {
            await adminDb.collection(COURSE_COLLECTION).doc(courseId).update({
                associations: [],
                updatedAt: new Date()
            });
        } catch (error) {
            console.error('Error removing course associations:', error);
            throw new Error('Failed to remove course associations');
        }
    }
}
